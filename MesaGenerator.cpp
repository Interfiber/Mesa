#include "MesaGenerator.h"
#include "Mesa.h"
#include "MesaUtils.h"

Mesa::Generator::Generator() = default;

std::string Mesa::MakefileGenerator::generate(std::shared_ptr<Workspace> workspace) {
    LOG("Generating Makefile for workspace...\n");

    std::string compilerPath;

    if (workspace->properties.count(Property::CompilerName) == 0) {
        LOG("No compiler set!");
        std::exit(0);
    }

    LOG("Checking for compiler: %s\n",
        workspace->properties[Property::CompilerName].c_str());

    std::vector<std::string> compilers =
            workspace->compilers.at(workspace->properties[Property::CompilerName]);

    bool fComp = false;
    for (auto &compiler: compilers) {
        LOG("Checking for compiler at: %s\n", compiler.c_str());
        if (std::filesystem::exists(compiler)) {
            LOG("Using compiler at: %s\n", compiler.c_str());

            compilerPath = compiler;
            fComp = true;

            break;
        }
    }

    if (!fComp) {
        LOG("Could not find a suitable compiler to use...");
        std::exit(EXIT_FAILURE);
    }

    std::string binDir;

    if (workspace->properties.find(Property::BuildDirectory) ==
        workspace->properties.end()) {
        LOG("No build directory set, using bin as default!");

        binDir = "bin";
    } else {
        binDir = workspace->properties[Property::BuildDirectory];
    }

    std::string result = "# This Makefile was generated by Mesa v2.1\n";
    result += "# Generation Date: " + std::to_string(std::time(nullptr)) + "\n";
    result += "# DO NOT EDIT THIS FILE AS IT WILL BE RE-GENERATED\n\n";

    result += "################### VARIABLES ###################\n\n";

    for (auto &var: workspace->variables) {
        result += var.first + " := " + var.second + "\n";
    }

    result += "CXX := " + Util_EscapeString(compilerPath) + "\n";
    result += "I_CPPFLAGS := -DMESA_BUILD\n";
    result += "BIN_DIR := " + binDir + "\n";
    result += "OBJ_DIR := $(BIN_DIR)/objs\n";

    for (auto &project: workspace->projects) {
        std::string defines;
        std::string includeDirs;
        std::string linkOpts = "-L" + binDir + " " + project->linkOptions;
        std::string staticLibs;

        for (auto &lib : project->staticLibraries) {
            std::string libPath = lib;
#if defined(_WIN32)
    libPath += ".lib";
#elif defined(__unix__)
    libPath += ".a";
#endif
            staticLibs += "$(BIN_DIR)/" + libPath + " ";
        }

        for (auto &opt: project->compilerDefines) {
            defines += "-D" + opt.first + "=" + opt.second + " ";
        }

        for (auto &include: project->includeDirectories) {
            defines += "-I" + include.generic_string() + " ";
            includeDirs += "$(wildcard " + include.generic_string() +
                           "/*.h) $(wildcard " + include.generic_string() + "/*.hpp)";
        }

        if (project->buildType == BuildType::SharedLibrary) {
            defines += " -fPIC ";
        }

        defines = Util_TrimString(defines);
        includeDirs = Util_TrimString(includeDirs);
        linkOpts = Util_TrimString(linkOpts);

        result +=
                Util_FixString(project->name) + "_INCDIRS := " + includeDirs + "\n";

        result += Util_FixString(project->name) + "_CPPFLAGS := " + defines + " " +
                  project->compilerOptions + "\n";

        result += Util_FixString(project->name) + "_LDFLAGS := " + linkOpts + "\n";

        result += Util_FixString(project->name) + "_STATIC_LIBS := " + staticLibs + "\n";
    }

    result += "\n################### PROJECTS ###################\n\n";

    std::string projectList;
    for (auto &project: workspace->projects) {
        projectList += Util_FixString(project->name) + " ";
    }

    result += "all: " + projectList + "\n\n";
    result += "clean:\n";
    result += "\t@echo [RM] Purging contents of $(BIN_DIR)\n";
    result += "\t@rm -rf $(BIN_DIR)/*\n\n";
    result += "Prep:\n";
    result += "\t@echo [MKDIR] Creating $(OBJ_DIR)\n";
    result += "\t@mkdir -p $(OBJ_DIR)\n";

    for (auto &project: workspace->projects) {
        result += "\t@mkdir -p $(OBJ_DIR)/" + Util_FixString(project->name);
    }

    result += "\n";

    for (auto &project: workspace->projects) {
        std::string fileList;

        for (auto &file: project->files) {
            fileList += file.generic_string() + " ";
        }

        std::vector<std::filesystem::path> objectFiles;
        std::string objFileListBlob;
        std::string objDir = "$(OBJ_DIR)/" + Util_FixString(project->name);

        for (auto &file: project->files) {
            objFileListBlob +=
                    objDir + "/" + Util_FixString(file.generic_string()) + ".o ";
        }

        // Generate compile steps for each source code file
        BuildType buildType = project->buildType;

        for (auto &file: project->files) {
            std::string objFileName = Util_FixString(file.generic_string()) + ".o";
            std::string projectCppFlags =
                    "$(" + Util_FixString(project->name) + "_CPPFLAGS)";
            std::string projectIncDirs =
                    "$(" + Util_FixString(project->name) + "_INCDIRS)";

            result += objDir + "/" + objFileName + ": " + file.generic_string() +
                      " " + projectIncDirs + "\n";
            result += "\t@echo [CXX] " + file.generic_string() + "\n";
            result += "\t@$(CXX) $(CPPFLAGS) " + projectCppFlags +
                      " $(I_CPPFLAGS) -c " + file.generic_string() + " -o " + objDir +
                      "/" + objFileName + "\n";
            result += "\n";

            objectFiles.push_back(objFileName);
        }

        std::string outName = Util_EscapeString(project->outputName);
        if (outName.empty()) {
            LOG("Output name for project %s is empty!\n", project->name.c_str());

            std::exit(EXIT_FAILURE);
        }

        if (buildType == BuildType::SharedLibrary) {
            outName = "lib" + outName;
#if defined(_WIN32)
            outName += ".dll";
#elif defined(__unix__)
            outName += ".so";
#endif
        } else if (buildType == BuildType::Executable) {
#if defined(_WIN32)
            outName += ".exe";
#endif
        } else if (buildType == BuildType::StaticLibrary) {
#if defined(_WIN32)
            outName += ".lib";
#elif defined(__unix)
            outName += ".a";
#endif
        }

        result +=
                Util_FixString(project->name) + ": Prep " + objFileListBlob + "\n";
        result += "\t@echo [EXE] Linking " + project->name + " \\> $(BIN_DIR)/" +
                  outName + "\n";

        std::string projectLdFlags = "$(" + Util_FixString(project->name) + "_LDFLAGS)";
        std::string projectStaticLibs = "$(" + Util_FixString(project->name) + "_STATIC_LIBS)";

        if (buildType == BuildType::Executable) {
            result +=
                    "\t@$(CXX) -o $(BIN_DIR)/" + outName + " " + objFileListBlob + " " + projectLdFlags + " " + projectStaticLibs + "\n";
        } else if (buildType == BuildType::StaticLibrary) {
            result += "\t@ar rcs $(BIN_DIR)/" + outName + " " + objFileListBlob;
        } else {
            result += "\t@$(CXX) -shared -o $(BIN_DIR)/" + outName + " " + objFileListBlob + " " + projectLdFlags + " -Wl,--whole-archive" + projectStaticLibs + "-Wl,--no-whole-archive\n";
        }

        result += "\n";
    }

    result += ".PHONY: clean\n";

    return result;
}
