#include "MesaGenerator.h"
#include "MesaUtils.h"

Mesa::Generator::Generator()
{
}

std::string Mesa::MakefileGenerator::generate(std::shared_ptr<Workspace> workspace)
{
	LOG("Generating Makefile for workspace...\n");

	std::string compilerPath;

	if (workspace->properties.count(Property::CompilerName) == 0) {
		LOG("No compiler set!");
		std::exit(0);
	}

	LOG("Checking for compiler: %s\n", workspace->properties[Property::CompilerName].c_str());

	std::vector<std::string> compilers = workspace->compilers.at(workspace->properties[Property::CompilerName]);

	bool fComp = false;
	for (auto& compiler : compilers) {
		LOG("Checking for compiler at: %s\n", compiler.c_str());
		if (std::filesystem::exists(compiler)) {
			LOG("Using compiler at: %s\n", compiler.c_str());

			compilerPath = compiler;
			fComp = true;

			break;
		}
	}

	if (!fComp) {
		LOG("Could not find a suitable compiler to use...");
		std::exit(EXIT_FAILURE);
	}

	std::string binDir;

	if (workspace->properties.find(Property::BuildDirectory) == workspace->properties.end()) {
		LOG("No build directory set, using bin as default!");

		binDir = "bin";
	}
	else {
		binDir = workspace->properties[Property::BuildDirectory];
	}

	std::string result = "# This Makefile was generated by Mesa v2.1\n";
	result += "# Generation Date: " + std::to_string(std::time(nullptr)) + "\n";
	result += "# DO NOT EDIT THIS FILE AS IT WILL BE RE-GENERATED\n\n";

	result += "################### VARIABLES ###################\n\n";

	for (auto& var : workspace->variables) {
		result += var.first + " := " + var.second + "\n";
	}

	result += "CXX := " + Util_EscapeString(compilerPath) + "\n";
	result += "I_CPPFLAGS := -DMESA_BUILD\n";
	result += "BIN_DIR := " + binDir + "\n";
	result += "OBJ_DIR := $(BIN_DIR)/objs\n";

	for (auto& project : workspace->projects) {
		std::string defines;
		std::string includeDirs;

		for (auto& opt : project->compilerDefines) {
			defines += "-D" + opt.first + "=" + opt.second + " ";
		}

		for (auto& include : project->includeDirectories) {
			defines += "-I" + include.generic_string() + " ";
			includeDirs += "$(wildcard " + include.generic_string() + "/*.h) $(wildcard " + include.generic_string() + "/*.hpp)";
		}

		defines = Util_TrimString(defines);
		includeDirs = Util_TrimString(includeDirs);

		result += Util_FixString(project->name) + "_INCDIRS := " + includeDirs + "\n";;
		result += Util_FixString(project->name) + "_CPPFLAGS := " + defines + " " + project->compilerOptions + "\n";
	}

	result += "\n################### PROJECTS ###################\n\n";
	
	std::string projectList;
	for (auto& project : workspace->projects) {
		projectList += Util_FixString(project->name) + " ";
	}

	result += "all: " + projectList + "\n\n";
	result += "clean:\n";
	result += "\t@echo [RM] Purging contents of $(BIN_DIR)\n";
	result += "\t@rm -rf $(BIN_DIR)/*\n\n";
	result += "Prep:\n";
	result += "\t@echo [MKDIR] Creating $(OBJ_DIR)\n";
	result += "\t@mkdir -p $(OBJ_DIR)\n";

	for (auto& project : workspace->projects) {
		result += "\t@mkdir -p $(OBJ_DIR)/" + Util_FixString(project->name);
	}

	result += "\n";

	for (auto& project : workspace->projects) {
		std::string fileList;

		for (auto& file : project->files) {
			fileList += file.generic_string() + " ";
		}

		std::vector<std::filesystem::path> objectFiles;
		std::string objFileListBlob;
		std::string objDir = "$(OBJ_DIR)/" + Util_FixString(project->name);

		for (auto& file : project->files) {
			objFileListBlob += objDir + "/" + Util_FixString(file.generic_string()) + ".o ";
		}

		// Generate compile steps for each source code file

		for (auto& file : project->files) {
			std::string objFileName = Util_FixString(file.generic_string()) + ".o";
			std::string projectCppFlags = "$(" + Util_FixString(project->name) + "_CPPFLAGS)";
			std::string projectIncDirs = "$(" + Util_FixString(project->name) + "_INCDIRS)";

			result += objDir + "/" + objFileName + ": " + file.generic_string() + " " + projectIncDirs + "\n";
			result += "\t@echo [CXX] " + file.generic_string()  + "\n";
			result += "\t@$(CXX) $(CPPFLAGS) " + projectCppFlags + " $(I_CPPFLAGS) -c " + file.generic_string() + " -o " + objDir + "/" + objFileName + "\n";
			result += "\n";

			objectFiles.push_back(objFileName);
		}

		std::string outName = Util_EscapeString(project->outputName);
		if (outName.empty()) {
			LOG("Output name for project %s is empty!\n", project->name.c_str());

			std::exit(EXIT_FAILURE);
		}

		result += Util_FixString(project->name) + ": Prep " + objFileListBlob + "\n";
		result += "\t@echo [EXE] Linking " + project->name + " \\> $(BIN_DIR)/" + outName + "\n";
		result += "\t@$(CXX) -o $(BIN_DIR)/" + outName + " " + objFileListBlob + "\n";
		result += "\n";
	}

	result += ".PHONY: clean\n";

	return result;
}
